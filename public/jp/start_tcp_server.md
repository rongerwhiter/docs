# TCPサーバー

## プログラムコード

以下のコードをtcpServer.phpに書き込んでください。

```php
//サーバーオブジェクトを作成し、127.0.0.1:9501ポートでリッスンします。
$server = new Swoole\Server('127.0.0.1', 9501);

//接続イベントをリッスンします。
$server->on('Connect', function ($server, $fd) {
    echo "Client: Connect.\n";
});

//データ受信イベントをリッスンします。
$server->on('Receive', function ($server, $fd, $reactor_id, $data) {
    $server->send($fd, "Server: {$data}");
});

//接続クローズイベントをリッスンします。
$server->on('Close', function ($server, $fd) {
    echo "Client: Close.\n";
});

//サーバーを起動します
$server->start(); 
```

これにより、`TCP`サーバーが作成され、ローカルの`9501`ポートをリッスンします。そのロジックは非常にシンプルで、クライアント`Socket`がネットワークを介して `hello`文字列を送信すると、サーバーは `Server: hello`文字列を返信します。

`Server`は非同期サーバーなので、イベントをリッスンしてプログラムを記述する方法で実装されています。対応するイベントが発生すると、その下の層が指定された関数を自動的にコールバックします。たとえば、新しい`TCP`接続があると[onConnect](/server/events?id=onconnect)イベントコールバックを実行し、ある接続がサーバーにデータを送信すると[onReceive](/server/events?id=onreceive)関数がコールバックされます。

* サーバーは何千ものクライアント接続を同時に持つことができ、`$fd`はクライアント接続の一意の識別子です。
* `$server->send()`メソッドを呼び出してクライアント接続にデータを送信し、引数は`$fd`クライアント識別子です。
* `$server->close()`メソッドを使用すると、特定のクライアント接続を強制的に閉じることができます。
* クライアントは自ら接続を切断することがあり、この場合は[onClose](/server/events?id=onclose)イベントコールバックが発生します。

## プログラムの実行

```shell
php tcpServer.php
```

このコマンドを使用して`server.php`プログラムをコマンドラインで実行すると、正常に起動されていることを確認できます。`netstat`ツールを使用してポート`9501`で既にリッスンしていることが確認できます。

その後、`telnet/netcat`ツールを使用してサーバーに接続できます。

```shell
telnet 127.0.0.1 9501
hello
Server: hello
```

## サーバーに接続できない場合の簡単なトラブルシューティング手段

* `Linux`では、`netstat -an | grep ポート`コマンドを使用して、ポートが既にリッスン状態にあるかどうかを確認します。
* 前のステップが確認されたら、ファイアウォールの問題を確認してください。
* サーバーが使用しているIPアドレスに注意してください。`127.0.0.1`の場合、クライアントは`127.0.0.1`だけで接続できます。
* Alibaba CloudやTencent Cloudを使用している場合は、セキュリティグループでポートを開放する必要があります。

## TCPデータパケットの境界問題

[TCPデータパケットの境界問題](/learn?id=tcpデータパケット辺界問題)を参照してください。
